<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Life Stats Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.45.4/dist/umd/supabase.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      min-height: 100vh;
      padding: 20px;
      color: #e0e0e0;
    }
    .container { max-width: 1400px; margin: 0 auto; }
    h1 {
      color: white;
      text-align: center;
      margin-bottom: 30px;
      font-size: 2.5em;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    }
    h2 { color: #e0e0e0; }
    .status {
      background: #2a2a3e;
      padding: 15px;
      border-radius: 10px;
      margin-bottom: 20px;
      text-align: center;
      font-weight: bold;
      color: #fff;
      border: 1px solid #667eea;
    }
    .tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }
    .tab {
      background: rgba(255,255,255,0.1);
      color: white;
      border: 1px solid rgba(255,255,255,0.2);
      padding: 12px 24px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 16px;
      transition: all 0.3s;
    }
    .tab:hover { background: rgba(255,255,255,0.2); }
    .tab.active { background: #667eea; color: white; border-color: #667eea; }
    .content { display: none; }
    .content.active { display: block; }
    
    .dashboard-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-bottom: 20px;
    }
    
    @media (max-width: 968px) {
      .dashboard-container { grid-template-columns: 1fr; }
    }
    
    .spider-chart-container {
      background: #2a2a3e;
      border-radius: 15px;
      padding: 25px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.5);
      border: 1px solid #3a3a4e;
    }
    
    .category-selector {
      background: #2a2a3e;
      border-radius: 15px;
      padding: 25px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.5);
      border: 1px solid #3a3a4e;
    }
    
    .category-btn {
      width: 100%;
      padding: 15px;
      margin-bottom: 10px;
      background: #1a1a2e;
      border: 2px solid #3a3a4e;
      border-radius: 10px;
      cursor: pointer;
      font-size: 16px;
      text-align: left;
      transition: all 0.3s;
      display: flex;
      justify-content: space-between;
      align-items: center;
      color: #e0e0e0;
    }
    
    .category-btn:hover { background: #252538; border-color: #667eea; }
    .category-btn.selected { 
      background: #667eea; 
      color: white; 
      border-color: #5568d3;
    }
    
    .detail-panel {
      background: #2a2a3e;
      border-radius: 15px;
      padding: 25px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.5);
      margin-top: 20px;
      border: 1px solid #3a3a4e;
    }
    
    .stat-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin: 20px 0;
    }
    
    .stat-item {
      background: #1a1a2e;
      padding: 15px;
      border-radius: 10px;
      border-left: 4px solid #667eea;
      transition: all 0.3s;
    }
    
    .stat-item:hover { background: #252538; transform: translateY(-2px); }
    
    .stat-item h4 {
      font-size: 0.9em;
      color: #999;
      margin-bottom: 8px;
    }
    
    .stat-value {
      font-size: 1.8em;
      font-weight: bold;
      color: #fff;
    }
    
    .stat-percentile {
      font-size: 1.2em;
      color: #667eea;
      margin-top: 5px;
    }
    
    .history-chart {
      background: #2a2a3e;
      border-radius: 15px;
      padding: 25px;
      margin-top: 20px;
      border: 1px solid #3a3a4e;
    }
    
    .chart-controls {
      background: #1a1a2e;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 15px;
      border: 1px solid #3a3a4e;
    }
    
    .control-group {
      display: flex;
      gap: 15px;
      align-items: center;
      flex-wrap: wrap;
      margin-bottom: 10px;
    }
    
    .control-group label {
      margin: 0;
      min-width: 80px;
    }
    
    .control-group select,
    .control-group input {
      width: auto;
      min-width: 120px;
    }
    
    .control-group input[type="number"] {
      width: 80px;
    }
    
    .custom-date-range {
      display: none;
      margin-top: 10px;
      padding: 10px;
      background: #252538;
      border-radius: 5px;
    }
    
    .input-section {
      background: #2a2a3e;
      border-radius: 15px;
      padding: 25px;
      margin-bottom: 20px;
      border: 1px solid #3a3a4e;
    }
    .form-group {
      margin-bottom: 15px;
    }
    label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
      color: #e0e0e0;
    }
    select, input, textarea {
      width: 100%;
      padding: 12px;
      border: 2px solid #3a3a4e;
      border-radius: 8px;
      font-size: 16px;
      background: #1a1a2e;
      color: #e0e0e0;
    }
    select:focus, input:focus, textarea:focus {
      outline: none;
      border-color: #667eea;
    }
    button {
      background: #667eea;
      color: white;
      border: none;
      padding: 12px 30px;
      border-radius: 8px;
      font-size: 16px;
      cursor: pointer;
      transition: background 0.3s;
      margin-right: 10px;
      margin-bottom: 10px;
    }
    button:hover { background: #5568d3; }
    button.secondary {
      background: #4a4a5e;
    }
    button.secondary:hover { background: #5a5a6e; }
    button.danger {
      background: #ef4444;
    }
    button.danger:hover { background: #dc2626; }
    
    .hierarchy-tree {
      margin-left: 20px;
      border-left: 2px solid #3a3a4e;
      padding-left: 15px;
      margin-top: 10px;
    }
    
    .hierarchy-item {
      background: #1a1a2e;
      padding: 10px;
      margin: 5px 0;
      border-radius: 5px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border: 1px solid #3a3a4e;
    }
    
    .overall-score {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border-radius: 20px;
      padding: 40px;
      text-align: center;
      margin-bottom: 30px;
      box-shadow: 0 20px 40px rgba(0,0,0,0.5);
    }
    .overall-score h2 { font-size: 2.5em; margin-bottom: 10px; color: white; }
    .overall-score .score { font-size: 5em; font-weight: bold; }
    
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }
    
    .modal.active { display: flex; }
    
    .modal-content {
      background: #2a2a3e;
      padding: 30px;
      border-radius: 15px;
      max-width: 600px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      border: 1px solid #3a3a4e;
    }
    
    .breadcrumb {
      background: #1a1a2e;
      padding: 10px 15px;
      border-radius: 8px;
      margin-bottom: 15px;
      font-size: 0.9em;
      color: #999;
      border: 1px solid #3a3a4e;
    }
    
    .metric-input-group {
      background: #1a1a2e;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 10px;
      border: 1px solid #3a3a4e;
    }
    
    .metric-label {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    
    .calculated-percentile {
      background: #667eea;
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 0.85em;
      font-weight: bold;
    }
    
    .settings-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
    }
    
    .settings-card {
      background: #1a1a2e;
      padding: 20px;
      border-radius: 10px;
      border: 1px solid #3a3a4e;
    }
    
    .settings-card h3 {
      margin-bottom: 15px;
      color: #667eea;
    }

    /* Data Management Styles */
    .data-tree { margin-top: 20px; }
    .tree-category { background: #1a1a2e; border: 1px solid #3a3a4e; border-radius: 8px; margin-bottom: 10px; overflow: hidden; }
    .tree-category-header { padding: 15px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; transition: background 0.3s; }
    .tree-category-header:hover { background: #252538; }
    .tree-category-header.expanded { background: #252538; border-bottom: 1px solid #3a3a4e; }
    .tree-category-title { display: flex; align-items: center; gap: 10px; font-weight: bold; }
    .tree-category-arrow { transition: transform 0.3s; font-size: 1.2em; }
    .tree-category-arrow.expanded { transform: rotate(90deg); }
    .tree-category-content { display: none; padding: 15px; padding-left: 30px; }
    .tree-category-content.expanded { display: block; }
    .data-entry { background: #2a2a3e; padding: 15px; border-radius: 8px; margin-bottom: 10px; border: 1px solid #3a3a4e; }
    .data-entry-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
    .data-entry-date { color: #999; font-size: 0.9em; }
    .data-entry-actions { display: flex; gap: 5px; }
    .data-entry-field { margin-bottom: 10px; }
    .data-entry-field label { font-size: 0.85em; color: #999; margin-bottom: 3px; }
    .data-entry-field input, .data-entry-field textarea { font-size: 0.95em; padding: 8px; }
    .data-entry.editing { border-color: #667eea; box-shadow: 0 0 10px rgba(102, 126, 234, 0.3); }
    .no-data-message { text-align: center; padding: 20px; color: #999; font-style: italic; }
    .search-filter { background: #1a1a2e; padding: 15px; border-radius: 8px; margin-bottom: 20px; border: 1px solid #3a3a4e; }
    .filter-row { display: flex; gap: 15px; align-items: end; flex-wrap: wrap; }
    .filter-group { flex: 1; min-width: 200px; }
    
  </style>
</head>
<body>
  <div class="container">
    <h1>üéÆ Personal Life Statistics Dashboard</h1>
    
    <div id="status" class="status">Initializing...</div>

    <div class="tabs">
      <button class="tab active" onclick="switchTab('dashboard')">üìä Dashboard</button>
      <button class="tab" onclick="switchTab('input')">‚ûï Add Data</button>
      <button class="tab" onclick="switchTab('datahistory')">üìù Manage Data</button>
      <button class="tab" onclick="switchTab('manage')">üóÇÔ∏è Manage Categories</button>
      <button class="tab" onclick="switchTab('settings')">‚öôÔ∏è Settings</button>
    </div>

    <!-- DASHBOARD TAB -->
    <div id="dashboard" class="content active">
      <div class="overall-score">
        <h2>Overall Weighted Score</h2>
        <div class="score" id="overallScore">--</div>
        <p>Based on your personalized importance weights</p>
      </div>

      <div class="dashboard-container">
        <div class="spider-chart-container">
          <h2>Overall Performance</h2>
          <canvas id="spiderChart"></canvas>
        </div>
        
        <div class="category-selector">
          <h2>Select Category</h2>
          <div id="categoryButtons"></div>
        </div>
      </div>
      
      <div id="detailPanel" class="detail-panel" style="display: none;">
        <div class="breadcrumb" id="breadcrumb"></div>
        <h2 id="detailTitle">Category Details</h2>
        <div class="stat-grid" id="detailStats"></div>
        <div class="history-chart">
          <div class="chart-controls">
            <div class="control-group">
              <label>Time Scale:</label>
              <select id="timeScale" onchange="updateChartSettings()">
                <option value="daily">Daily</option>
                <option value="weekly">Weekly</option>
                <option value="monthly" selected>Monthly</option>
                <option value="yearly">Yearly</option>
                <option value="custom">Custom Range</option>
              </select>
              
              <label>Go Back:</label>
              <input type="number" id="timeUnits" value="6" min="1" max="100" onchange="updateChartSettings()">
              <span id="timeUnitsLabel">months</span>
              
              <button onclick="refreshChart()" style="margin: 0;">Refresh</button>
            </div>
            
            <div id="customDateRange" class="custom-date-range">
              <div class="control-group">
                <label>Start Date:</label>
                <input type="date" id="customStartDate">
                
                <label>End Date:</label>
                <input type="date" id="customEndDate">
                
                <label>Aggregate By:</label>
                <select id="customAggregation">
                  <option value="daily">Daily</option>
                  <option value="weekly">Weekly</option>
                  <option value="monthly">Monthly</option>
                  <option value="yearly">Yearly</option>
                </select>
              </div>
            </div>
          </div>
          <canvas id="detailChart"></canvas>
        </div>
      </div>
    </div>

    <!-- INPUT TAB -->
    <div id="input" class="content">
      <div class="input-section">
        <h2>Add New Metric Values</h2>
        <div class="breadcrumb" id="inputBreadcrumb">Select category path</div>
        <div class="form-group">
          <label>Category Path</label>
          <select id="categoryPathSelect" onchange="updateMetricInputs()">
            <option value="">Select...</option>
          </select>
        </div>
        <div id="metricInputsContainer"></div>
        <div class="form-group">
          <label>Comparison Group</label>
          <select id="comparisonGroup">
            <option value="age_group">My Age Group</option>
            <option value="gender">My Gender</option>
            <option value="age_and_gender">Age + Gender</option>
            <option value="general">General Population</option>
          </select>
        </div>
        <button onclick="addMetricValues()">Add Values</button>
      </div>
    </div>

    <!-- DATA HISTORY TAB -->
    <div id="datahistory" class="content">
      <div class="input-section">
        <h2>Data History & Management</h2>
        
        <div class="search-filter">
          <div class="filter-row">
            <div class="filter-group">
              <label>Filter by Category</label>
              <select id="filterCategory" onchange="loadDataHistory()">
                <option value="">All Categories</option>
              </select>
            </div>
            <div class="filter-group">
              <label>Start Date</label>
              <input type="date" id="filterStartDate" onchange="loadDataHistory()">
            </div>
            <div class="filter-group">
              <label>End Date</label>
              <input type="date" id="filterEndDate" onchange="loadDataHistory()">
            </div>
            <div class="filter-group" style="display: flex; align-items: flex-end;">
              <button onclick="clearFilters()">Clear Filters</button>
            </div>
          </div>
        </div>
    
        <div id="dataHistoryTree" class="data-tree"></div>
      </div>
    </div>
    
    <!-- MANAGE CATEGORIES TAB -->
    <div id="manage" class="content">
      <div class="input-section">
        <h2>Category Hierarchy</h2>
        <button onclick="openAddCategoryModal()">+ Add New Category</button>
        <button onclick="openAddSubCategoryModal()" class="secondary">+ Add Sub-Category</button>
        <div id="categoryHierarchy" style="margin-top: 20px;"></div>
      </div>
    </div>

    <!-- SETTINGS TAB -->
    <div id="settings" class="content">
      <div class="input-section">
        <h2>Personal Information</h2>
        <div class="settings-grid">
          <div class="settings-card">
            <h3>Basic Info</h3>
            <div class="form-group">
              <label>Age</label>
              <input type="number" id="userAge" placeholder="e.g., 28">
            </div>
            <div class="form-group">
              <label>Gender</label>
              <select id="userGender">
                <option value="">Select...</option>
                <option value="male">Male</option>
                <option value="female">Female</option>
                <option value="other">Other</option>
              </select>
            </div>
            <div class="form-group">
              <label>Weight (lbs or kg)</label>
              <input type="number" id="userWeight" placeholder="e.g., 180">
            </div>
            <div class="form-group">
              <label>Location</label>
              <input type="text" id="userLocation" placeholder="e.g., Canada">
            </div>
            <button onclick="savePersonalInfo()">Save Personal Info</button>
          </div>
        </div>
      </div>
      
      <div class="input-section" style="margin-top: 20px;">
        <h2>Category Importance Weights</h2>
        <p style="margin-bottom: 20px; color: #999;">Adjust how much each domain matters to you (1-10)</p>
        <div id="weightsForm"></div>
        <button onclick="saveWeights()">Save Weights</button>
      </div>
    </div>
  </div>

  <!-- MODAL FOR ADDING/EDITING CATEGORIES -->
  <div id="categoryModal" class="modal">
    <div class="modal-content">
      <h2 id="modalTitle">Add Category</h2>
      <input type="hidden" id="modalEditPath">
      <input type="hidden" id="modalOriginalPath">
      <div class="form-group">
        <label>Parent Category (optional)</label>
        <select id="modalParentSelect">
          <option value="">Top Level</option>
        </select>
      </div>
      <div class="form-group">
        <label>Category Name</label>
        <input type="text" id="modalCategoryName" placeholder="e.g., Strength Training">
      </div>
      <div class="form-group">
        <label>Icon (emoji, optional)</label>
        <input type="text" id="modalCategoryIcon" placeholder="Leave empty for no icon" maxlength="2">
      </div>
      
      <h3 style="margin-top: 20px; margin-bottom: 10px;">Metrics for this Category</h3>
      <div id="metricsContainer"></div>
      <button onclick="addMetricField()" class="secondary">+ Add Metric</button>
      
      <div style="margin-top: 20px;">
        <button onclick="saveCategory()">Save Category</button>
        <button onclick="closeModal()" class="secondary">Cancel</button>
      </div>
    </div>
  </div>

  <script src="js/percentile/percentile-functions-config.js"></script>
  <script src="js/percentile/index.js"></script>
  <script src="js/percentile/percentile-physical.js"></script>
  <script src="js/percentile/percentile-cognitive.js"></script>
  <script src="js/percentile/percentile-financial.js"></script>
  <script src="js/percentile/percentile-social.js"></script>
  <script src="js/percentile/percentile-emotional.js"></script>
  <script>
    const SUPABASE_URL = "https://sugekxazhhxmbzncqxyg.supabase.co";
    const SUPABASE_KEY = "sb_publishable_84h5tEu4ALMHkJWBxQeYdw_WqSSJiKd";
    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

    let categoryStructure = [];
    let spiderChart, detailChart;
    let currentWeights = {};
    let selectedCategory = null;
    let userProfile = {};
    let metricDefinitions = [];
    let chartSettings = {
      scale: 'monthly',
      units: 6,
      customStart: null,
      customEnd: null,
      customAggregation: 'daily'
    };

    let expandedCategories = new Set();
    let editingEntries = new Set();

    // percentileFunctions is now loaded from js/percentile/index.js

    // INITIALIZE
    async function init() {
      // 1. Initial status update (Keep for connection check)
      document.getElementById("status").textContent = "‚úÖ Connected to Supabase"; 
      
      // 2. Load necessary reference data first
      await loadPersonalInfo();
      
      // Load categories (structure)
      const categoriesLoaded = await loadCategoryStructure(false); // <--- Pass false to suppress internal population
      
      // 3. Load metric definitions (CRITICAL: Must happen before population)
      if (categoriesLoaded) {
        await loadMetricDefinitions(); 
        
        // 4. Now that metrics are defined, populate selectors and continue initialization
        populateCategorySelectors(); // <--- Manual call after metrics are loaded
        populateDataHistoryFilters();
    
        await loadWeights();
        await loadDashboard();
        document.getElementById("status").textContent = "‚úÖ Dashboard initialized and connected!";
      } else {
        document.getElementById("status").textContent = "‚ùå Critical: Failed to load categories and defaults.";
      }
    }

    // LOAD PERSONAL INFO
    async function loadPersonalInfo() {
      const { data, error } = await supabase
        .from("user_profile")
        .select("*")
        .single();

      if (data) {
        userProfile = data;
        document.getElementById("userAge").value = data.age || "";
        document.getElementById("userGender").value = data.gender || "";
        document.getElementById("userWeight").value = data.weight || "";
        document.getElementById("userLocation").value = data.location || "";
      }
    }

    // SAVE PERSONAL INFO
    async function savePersonalInfo() {
      const age = parseInt(document.getElementById("userAge").value);
      const gender = document.getElementById("userGender").value;
      const weight = parseFloat(document.getElementById("userWeight").value);
      const location = document.getElementById("userLocation").value;

      const { error } = await supabase
        .from("user_profile")
        .upsert({ 
          id: 1, 
          age, 
          gender,
          weight,
          location,
          updated_at: new Date().toISOString()
        });

      if (error) {
        console.error(error);
        alert("Failed to save personal info");
        return;
      }

      userProfile = { age, gender, weight, location };
      document.getElementById("status").textContent = "‚úÖ Personal info saved!";
    }

    function switchTab(tabName) {
      document.querySelectorAll('.content').forEach(c => c.classList.remove('active'));
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      document.getElementById(tabName).classList.add('active');
      event.target.classList.add('active');
      
      if (tabName === 'manage') {
        renderCategoryHierarchy();
      } else if (tabName === 'datahistory') {
        loadDataHistory();
      }
    }

    // LOAD CATEGORY STRUCTURE
    async function loadCategoryStructure(doPopulate = true) {
      const { data, error } = await supabase
        .from("category_structure")
        .select("*")
        .order("path", { ascending: true });

      if (error || !data || data.length === 0) {
        await initializeDefaultStructure();
        const { data: newData } = await supabase
          .from("category_structure")
          .select("*")
          .order("path", { ascending: true });

        if (!newData || newData.length === 0) return false;
        categoryStructure = newData;
        populateCategorySelectors();
        return true;
      }

      categoryStructure = data;
      if (doPopulate) {
        populateCategorySelectors(); // Only run if flag is true
      }
      return true;
    }

    // LOAD METRIC DEFINITIONS
    async function loadMetricDefinitions() {
      const { data, error } = await supabase
        .from("metric_definitions")
        .select("*");

      if (data) {
        metricDefinitions = data;
      }
    }

    // INITIALIZE DEFAULT STRUCTURE
    async function initializeDefaultStructure() {
      const defaults = [
        { path: "physical", name: "Physical", icon: "üí™", parent_path: null },
        { path: "physical.strength", name: "Strength", icon: "üèãÔ∏è", parent_path: "physical" },
        { path: "cognitive", name: "Cognitive", icon: "üß†", parent_path: null },
        { path: "social", name: "Social", icon: "üó£Ô∏è", parent_path: null },
        { path: "financial", name: "Financial", icon: "üí∞", parent_path: null },
        { path: "financial.networth", name: "Net Worth", icon: "üíé", parent_path: "financial" },
        { path: "emotional", name: "Emotional", icon: "üòå", parent_path: null }
      ];

      await supabase.from("category_structure").insert(defaults);
      
      // Add default metrics
      const defaultMetrics = [
        { category_path: "financial.networth", metric_name: "Net Worth", unit: "USD", percentile_function: "networth_percentile", parameters: ["value", "age"] },
        { category_path: "physical.strength", metric_name: "Bench Press", unit: "lbs", percentile_function: "bench_press_percentile", parameters: ["weight", "age", "bodyweight"] }
      ];
      
      await supabase.from("metric_definitions").insert(defaultMetrics);
    }

    function getTopLevelCategories() {
      return categoryStructure.filter(c => !c.parent_path);
    }

    function getChildren(path) {
      return categoryStructure.filter(c => c.parent_path === path);
    }

    function buildCategoryTree(parentPath = null, level = 0) {
      const categories = parentPath === null ? getTopLevelCategories() : getChildren(parentPath);
      return categories.map(cat => ({
        ...cat,
        level,
        children: buildCategoryTree(cat.path, level + 1)
      }));
    }

    function populateCategorySelectors() {
      // Populate dashboard category buttons (top-level only)
      const buttonContainer = document.getElementById("categoryButtons");
      buttonContainer.innerHTML = "";
      
      getTopLevelCategories().forEach(cat => {
        const btn = document.createElement("button");
        btn.className = "category-btn";
        btn.innerHTML = `<span>${cat.icon} ${cat.name}</span><span>‚Üí</span>`;
        btn.onclick = () => selectCategory(cat.path);
        buttonContainer.appendChild(btn);
      });
    
      // Populate INPUT tab select (only categories with metrics)
      const pathSelect = document.getElementById("categoryPathSelect");
      pathSelect.innerHTML = '<option value="">Select...</option>';
      
      function addInputOptions(cats, prefix = "") {
        cats.forEach(cat => {
          const hasMetrics = metricDefinitions.some(m => m.category_path === cat.path);
          
          if (hasMetrics) {
            const option = document.createElement("option");
            option.value = cat.path;
            option.textContent = prefix + (cat.icon || "") + (cat.icon ? " " : "") + cat.name;
            pathSelect.appendChild(option);
          }
          
          if (cat.children && cat.children.length > 0) {
            addInputOptions(cat.children, prefix + "  ");
          }
        });
      }
      
      addInputOptions(buildCategoryTree());
    
      // Populate MODAL parent select (ALL categories)
      const parentSelect = document.getElementById("modalParentSelect");
      parentSelect.innerHTML = '<option value="">Top Level</option>';
      
      function addAllCategoryOptions(cats, prefix = "") {
        cats.forEach(cat => {
          const option = document.createElement("option");
          option.value = cat.path;
          option.textContent = prefix + (cat.icon || "") + (cat.icon ? " " : "") + cat.name;
          parentSelect.appendChild(option);
          
          if (cat.children && cat.children.length > 0) {
            addAllCategoryOptions(cat.children, prefix + "  ");
          }
        });
      }
      
      addAllCategoryOptions(buildCategoryTree());
    }

    // UPDATE METRIC INPUTS
    async function updateMetricInputs() {
      const categoryPath = document.getElementById("categoryPathSelect").value;
      const container = document.getElementById("metricInputsContainer");
      container.innerHTML = "";

      if (!categoryPath) return;

      const cat = categoryStructure.find(c => c.path === categoryPath);
      document.getElementById("inputBreadcrumb").textContent = `${cat.icon} ${cat.name}`;

      const metrics = metricDefinitions.filter(m => m.category_path === categoryPath);

      if (metrics.length === 0) {
        container.innerHTML = "<p style='color: #999;'>No metrics defined for this category. Add metrics in Manage Categories.</p>";
        return;
      }

      metrics.forEach(metric => {
        const div = document.createElement("div");
        div.className = "metric-input-group";
        div.innerHTML = `
          <div class="metric-label">
            <label>${metric.metric_name} (${metric.unit})</label>
            <span class="calculated-percentile" id="percentile_${metric.id}" style="display: none;"></span>
          </div>
          <input type="number" step="any" id="metric_${metric.id}" 
                 placeholder="Enter ${metric.metric_name.toLowerCase()}" 
                 oninput="calculatePercentileForMetric(${metric.id})">
        `;
        container.appendChild(div);
      });
    }

    // CALCULATE PERCENTILE FOR METRIC
    function calculatePercentileForMetric(metricId) {
      const metric = metricDefinitions.find(m => m.id === metricId);
      if (!metric || !metric.percentile_function) return;

      const value = parseFloat(document.getElementById(`metric_${metricId}`).value);
      if (isNaN(value)) return;

      const funcName = metric.percentile_function;
      const func = percentileFunctions[funcName];
      
      if (!func) return;

      // Build parameters array
      const params = [value];
      if (metric.parameters && Array.isArray(metric.parameters)) {
        metric.parameters.forEach(param => {
          if (param === 'age' && userProfile.age) params.push(userProfile.age);
          if (param === 'gender' && userProfile.gender) params.push(userProfile.gender);
          if (param === 'bodyweight') {
            // Try to find bodyweight metric in current inputs
            const bwMetric = metricDefinitions.find(m => 
              m.category_path.includes('physical') && m.metric_name.toLowerCase().includes('weight')
            );
            if (bwMetric) {
              const bw = parseFloat(document.getElementById(`metric_${bwMetric.id}`)?.value);
              if (!isNaN(bw)) params.push(bw);
            }
          }
        });
      }

      try {
        const percentile = func(...params);
        const displayEl = document.getElementById(`percentile_${metricId}`);
        displayEl.textContent = `${Math.round(percentile)}th percentile`;
        displayEl.style.display = 'inline-block';
      } catch (e) {
        console.error("Error calculating percentile:", e);
      }
    }

    // ADD METRIC VALUES
    async function addMetricValues() {
      const categoryPath = document.getElementById("categoryPathSelect").value;
      const comparisonGroup = document.getElementById("comparisonGroup").value;

      if (!categoryPath) {
        alert("Please select a category");
        return;
      }

      const metrics = metricDefinitions.filter(m => m.category_path === categoryPath);
      const entries = [];

      for (const metric of metrics) {
        const value = parseFloat(document.getElementById(`metric_${metric.id}`).value);
        if (isNaN(value)) continue;

        let percentile = null;

        // Calculate percentile if function exists
        if (metric.percentile_function && percentileFunctions[metric.percentile_function]) {
          const func = percentileFunctions[metric.percentile_function];
          const params = [value];
          
          if (metric.parameters && Array.isArray(metric.parameters)) {
            metric.parameters.forEach(param => {
              if (param === 'age' && userProfile.age) params.push(userProfile.age);
              if (param === 'gender' && userProfile.gender) params.push(userProfile.gender);
              if (param === 'bodyweight') {
                const bwMetric = metricDefinitions.find(m => 
                  m.category_path.includes('physical') && m.metric_name.toLowerCase().includes('weight')
                );
                if (bwMetric) {
                  const bw = parseFloat(document.getElementById(`metric_${bwMetric.id}`)?.value);
                  if (!isNaN(bw)) params.push(bw);
                }
              }
            });
          }

          try {
            percentile = Math.round(func(...params));
          } catch (e) {
            console.error("Percentile calculation error:", e);
          }
        }

        entries.push({
          category_path: categoryPath,
          metric_id: metric.id,
          metric_name: metric.metric_name,
          value,
          percentile,
          comparison_group: comparisonGroup
        });
      }

      if (entries.length === 0) {
        alert("Please enter at least one metric value");
        return;
      }

      const { error } = await supabase.from("metric_values").insert(entries);

      if (error) {
        console.error(error);
        document.getElementById("status").textContent = "‚ùå Insert failed";
        return;
      }

      document.getElementById("status").textContent = "‚úÖ Values added!";
      
      // Clear inputs
      metrics.forEach(m => {
        const input = document.getElementById(`metric_${m.id}`);
        if (input) input.value = "";
        const percentileEl = document.getElementById(`percentile_${m.id}`);
        if (percentileEl) percentileEl.style.display = 'none';
      });
      
      await loadDashboard();
      if (selectedCategory) {
        await loadDetailStats(selectedCategory);
      }
    }

    // SELECT CATEGORY
    async function selectCategory(path) {
      selectedCategory = path;
      
      document.querySelectorAll('.category-btn').forEach(btn => {
        btn.classList.remove('selected');
      });
      event.target.closest('.category-btn').classList.add('selected');
      
      document.getElementById("detailPanel").style.display = "block";
      
      const breadcrumb = document.getElementById("breadcrumb");
      const pathParts = path.split('.');
      let breadcrumbHTML = "Home";
      let currentPath = "";
      
      pathParts.forEach((part, i) => {
        currentPath = i === 0 ? part : currentPath + "." + part;
        const cat = categoryStructure.find(c => c.path === currentPath);
        if (cat) {
          breadcrumbHTML += ` > ${cat.icon} ${cat.name}`;
        }
      });
      breadcrumb.textContent = breadcrumbHTML;
      
      const category = categoryStructure.find(c => c.path === path);
      document.getElementById("detailTitle").textContent = `${category.icon} ${category.name}`;
      
      await loadDetailStats(path);
    }

    // LOAD DETAIL STATS
    async function loadDetailStats(path) {
      const descendants = getDescendants(path);
      const allPaths = [path, ...descendants.map(d => d.path)];
      
      const { data, error } = await supabase
        .from("metric_values")
        .select("*")
        .in("category_path", allPaths)
        .order("created_at", { ascending: false });

      if (error) {
        console.error(error);
        return;
      }

      const statsGrid = document.getElementById("detailStats");
      statsGrid.innerHTML = "";
      
      const grouped = {};
      data.forEach(entry => {
        if (!grouped[entry.category_path]) {
          grouped[entry.category_path] = {};
        }
        if (!grouped[entry.category_path][entry.metric_name]) {
          grouped[entry.category_path][entry.metric_name] = [];
        }
        grouped[entry.category_path][entry.metric_name].push(entry);
      });

      const children = getChildren(path);
      children.forEach(child => {
        const childData = grouped[child.path];
        if (childData) {
          Object.keys(childData).forEach(metricName => {
            const latest = childData[metricName][0];
            const statItem = document.createElement("div");
            statItem.className = "stat-item";
            statItem.style.cursor = "pointer";
            statItem.onclick = () => selectCategory(child.path);
            statItem.innerHTML = `
              <h4>${child.icon} ${child.name} - ${metricName}</h4>
              <div class="stat-value">${latest.value}</div>
              <div class="stat-percentile">${latest.percentile ? latest.percentile + 'th percentile' : 'No percentile'}</div>
            `;
            statsGrid.appendChild(statItem);
          });
        }
      });

      if (children.length === 0 && grouped[path]) {
        Object.keys(grouped[path]).forEach(metricName => {
          const latest = grouped[path][metricName][0];
          const statItem = document.createElement("div");
          statItem.className = "stat-item";
          statItem.innerHTML = `
            <h4>${metricName}</h4>
            <div class="stat-value">${latest.value}</div>
            <div class="stat-percentile">${latest.percentile ? latest.percentile + 'th percentile' : 'No percentile'}</div>
            <div style="font-size: 0.8em; color: #999; margin-top: 10px;">
              ${new Date(latest.created_at).toLocaleDateString()}
            </div>
          `;
          statsGrid.appendChild(statItem);
        });
      }

      await loadDetailChart(path);
    }

    function getDescendants(path) {
      const direct = getChildren(path);
      let all = [...direct];
      direct.forEach(child => {
        all = all.concat(getDescendants(child.path));
      });
      return all;
    }

    // LOAD DETAIL CHART
    async function loadDetailChart(path) {
      const children = getChildren(path);
      const allPaths = children.length > 0 ? children.map(c => c.path) : [path];

      // Calculate date range based on settings
      const endDate = new Date();
      let startDate = new Date();
      
      if (chartSettings.scale === 'custom') {
        startDate = chartSettings.customStart ? new Date(chartSettings.customStart) : new Date(endDate - 180 * 24 * 60 * 60 * 1000);
        endDate.setTime(chartSettings.customEnd ? new Date(chartSettings.customEnd).getTime() : Date.now());
      } else {
        const units = chartSettings.units || 6;
        switch (chartSettings.scale) {
          case 'daily':
            startDate.setDate(startDate.getDate() - units);
            break;
          case 'weekly':
            startDate.setDate(startDate.getDate() - units * 7);
            break;
          case 'monthly':
            startDate.setMonth(startDate.getMonth() - units);
            break;
          case 'yearly':
            startDate.setFullYear(startDate.getFullYear() - units);
            break;
        }
      }

      const { data, error } = await supabase
        .from("metric_values")
        .select("*")
        .in("category_path", allPaths)
        .gte("created_at", startDate.toISOString())
        .lte("created_at", endDate.toISOString())
        .order("created_at", { ascending: true });

      if (error) return;

      const ctx = document.getElementById("detailChart");
      if (detailChart) detailChart.destroy();

      // Determine aggregation level
      const aggregationScale = chartSettings.scale === 'custom' ? 
        chartSettings.customAggregation : 
        getAggregationLevel(chartSettings.scale);

      // Aggregate data
      const aggregatedData = aggregateData(data, aggregationScale);

      // Build datasets
      const datasets = {};
      aggregatedData.forEach(entry => {
        const key = `${entry.category_path}_${entry.metric_name}`;
        if (!datasets[key]) {
          const cat = categoryStructure.find(c => c.path === entry.category_path);
          datasets[key] = {
            label: (cat ? cat.icon + " " + cat.name + " - " : "") + entry.metric_name,
            data: [],
            tension: 0.3,
            borderWidth: 2
          };
        }
      });

      const labels = [];
      aggregatedData.forEach(entry => {
        const dateLabel = formatDateLabel(entry.date, aggregationScale);
        if (!labels.includes(dateLabel)) labels.push(dateLabel);
        
        const key = `${entry.category_path}_${entry.metric_name}`;
        if (datasets[key] && entry.percentile !== null) {
          datasets[key].data.push({
            x: dateLabel,
            y: entry.percentile
          });
        }
      });

      detailChart = new Chart(ctx, {
        type: "line",
        data: {
          labels,
          datasets: Object.values(datasets)
        },
        options: {
          responsive: true,
          plugins: {
            title: { 
              display: true, 
              text: `Historical Progress (${aggregationScale} averages)`,
              color: '#e0e0e0'
            },
            legend: {
              labels: { color: '#e0e0e0' }
            }
          },
          scales: {
            y: { 
              min: 0, 
              max: 100, 
              title: { display: true, text: "Percentile", color: '#e0e0e0' },
              ticks: { color: '#e0e0e0' },
              grid: { color: '#3a3a4e' }
            },
            x: {
              ticks: { color: '#e0e0e0' },
              grid: { color: '#3a3a4e' }
            }
          }
        }
      });
    }

    // Get aggregation level (one level below selected scale)
    function getAggregationLevel(scale) {
      const levels = ['hourly', 'daily', 'weekly', 'monthly', 'yearly'];
      const currentIndex = levels.indexOf(scale);
      return currentIndex > 0 ? levels[currentIndex - 1] : 'hourly';
    }

    // Aggregate data by time period
    function aggregateData(rawData, aggregationScale) {
      const grouped = {};
      
      rawData.forEach(entry => {
        const date = new Date(entry.created_at);
        let periodKey;
        
        switch (aggregationScale) {
          case 'hourly':
            const hour = String(date.getHours()).padStart(2, '0');
            periodKey = `${date.toISOString().split('T')[0]} ${hour}:00`;
            break;
          case 'daily':
            periodKey = date.toISOString().split('T')[0]; // YYYY-MM-DD
            break;
          case 'weekly':
            const weekStart = new Date(date);
            weekStart.setDate(date.getDate() - date.getDay()); // Start of week (Sunday)
            periodKey = weekStart.toISOString().split('T')[0];
            break;
          case 'monthly':
            periodKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
            break;
          case 'yearly':
            periodKey = `${date.getFullYear()}`;
            break;
          default:
            periodKey = date.toISOString().split('T')[0];
        }
        
        const key = `${entry.category_path}_${entry.metric_name}_${periodKey}`;
        
        if (!grouped[key]) {
          grouped[key] = {
            category_path: entry.category_path,
            metric_name: entry.metric_name,
            date: periodKey,
            percentiles: [],
            values: []
          };
        }
        
        if (entry.percentile !== null) {
          grouped[key].percentiles.push(entry.percentile);
        }
        if (entry.value !== null) {
          grouped[key].values.push(entry.value);
        }
      });
      
      // Calculate averages
      return Object.values(grouped).map(group => ({
        category_path: group.category_path,
        metric_name: group.metric_name,
        date: group.date,
        percentile: group.percentiles.length > 0 ? 
          group.percentiles.reduce((a, b) => a + b) / group.percentiles.length : null,
        value: group.values.length > 0 ?
          group.values.reduce((a, b) => a + b) / group.values.length : null
      }));
    }

    // Format date label based on aggregation
    function formatDateLabel(dateStr, aggregationScale) {
      const date = new Date(dateStr);
      
      switch (aggregationScale) {
        case 'hourly':
          return date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false });
        case 'daily':
          return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        case 'weekly':
          return `Week of ${date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}`;
        case 'monthly':
          return date.toLocaleDateString('en-US', { year: 'numeric', month: 'short' });
        case 'yearly':
          return date.getFullYear().toString();
        default:
          return date.toLocaleDateString();
      }
    }

    // Update chart settings UI
    function updateChartSettings() {
      const scale = document.getElementById("timeScale").value;
      const units = document.getElementById("timeUnits").value;
      
      chartSettings.scale = scale;
      chartSettings.units = parseInt(units);
      
      // Update label
      const labelMap = {
        daily: 'days',
        weekly: 'weeks',
        monthly: 'months',
        yearly: 'years'
      };
      document.getElementById("timeUnitsLabel").textContent = labelMap[scale] || '';
      
      // Show/hide custom date range
      const customRange = document.getElementById("customDateRange");
      if (scale === 'custom') {
        customRange.style.display = 'block';
        document.getElementById("timeUnits").disabled = true;
        
        // Set default dates if empty
        if (!document.getElementById("customEndDate").value) {
          document.getElementById("customEndDate").value = new Date().toISOString().split('T')[0];
        }
        if (!document.getElementById("customStartDate").value) {
          const sixMonthsAgo = new Date();
          sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
          document.getElementById("customStartDate").value = sixMonthsAgo.toISOString().split('T')[0];
        }
        
        chartSettings.customStart = document.getElementById("customStartDate").value;
        chartSettings.customEnd = document.getElementById("customEndDate").value;
        chartSettings.customAggregation = document.getElementById("customAggregation").value;
      } else {
        customRange.style.display = 'none';
        document.getElementById("timeUnits").disabled = false;
      }
    }

    // Refresh chart with current settings
    function refreshChart() {
      if (chartSettings.scale === 'custom') {
        chartSettings.customStart = document.getElementById("customStartDate").value;
        chartSettings.customEnd = document.getElementById("customEndDate").value;
        chartSettings.customAggregation = document.getElementById("customAggregation").value;
      }
      
      if (selectedCategory) {
        loadDetailChart(selectedCategory);
      }
    }

    // LOAD SPIDER CHART
    async function loadDashboard() {
      const topLevel = getTopLevelCategories();
      const categoryAverages = {};
      
      for (const cat of topLevel) {
        const descendants = getDescendants(cat.path);
        const allPaths = [cat.path, ...descendants.map(d => d.path)];
        
        const { data, error } = await supabase
          .from("metric_values")
          .select("percentile")
          .in("category_path", allPaths)
          .not("percentile", "is", null)
          .order("created_at", { ascending: false })
          .limit(10);

        if (data && data.length > 0) {
          const avg = data.reduce((sum, d) => sum + d.percentile, 0) / data.length;
          categoryAverages[cat.path] = avg;
        } else {
          categoryAverages[cat.path] = 0;
        }
      }

      const ctx = document.getElementById("spiderChart");
      if (spiderChart) spiderChart.destroy();

      spiderChart = new Chart(ctx, {
        type: "radar",
        data: {
          labels: topLevel.map(c => c.icon + " " + c.name),
          datasets: [{
            label: "Current Percentiles",
            data: topLevel.map(c => categoryAverages[c.path] || 0),
            backgroundColor: "rgba(102, 126, 234, 0.3)",
            borderColor: "#667eea",
            borderWidth: 2,
            pointBackgroundColor: "#667eea",
            pointBorderColor: "#fff",
            pointBorderWidth: 2
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          plugins: {
            legend: {
              labels: { color: '#e0e0e0' }
            }
          },
          scales: {
            r: {
              min: 0,
              max: 100,
              ticks: { 
                stepSize: 20,
                color: '#e0e0e0',
                backdropColor: 'transparent'
              },
              grid: { color: '#3a3a4e' },
              pointLabels: { color: '#e0e0e0' }
            }
          }
        }
      });

      let totalWeighted = 0;
      let totalWeight = 0;

      topLevel.forEach(cat => {
        const weight = currentWeights[cat.path] || 5;
        totalWeighted += (categoryAverages[cat.path] || 0) * weight;
        totalWeight += weight;
      });

      const overallScore = totalWeight > 0 ? Math.round(totalWeighted / totalWeight) : 0;
      document.getElementById("overallScore").textContent = overallScore;
    }

    // MODAL FUNCTIONS
    let metricFieldCounter = 0;

    function openAddCategoryModal() {
      document.getElementById("modalTitle").textContent = "Add Top-Level Category";
      document.getElementById("modalEditPath").value = "";
      document.getElementById("modalParentSelect").value = "";
      document.getElementById("modalCategoryName").value = "";
      document.getElementById("modalCategoryIcon").value = "";
      document.getElementById("metricsContainer").innerHTML = "";
      metricFieldCounter = 0;
      document.getElementById("categoryModal").classList.add("active");
    }

    function openAddSubCategoryModal() {
      document.getElementById("modalTitle").textContent = "Add Sub-Category";
      document.getElementById("modalEditPath").value = "";
      document.getElementById("modalCategoryName").value = "";
      document.getElementById("modalCategoryIcon").value = "";
      document.getElementById("metricsContainer").innerHTML = "";
      metricFieldCounter = 0;
      document.getElementById("categoryModal").classList.add("active");
    }

    function openEditCategoryModal(path) {
      const category = categoryStructure.find(c => c.path === path);
      if (!category) return;

      document.getElementById("modalTitle").textContent = "Edit Category";
      document.getElementById("modalEditPath").value = path;
      document.getElementById("modalOriginalPath").value = path;
      document.getElementById("modalParentSelect").value = category.parent_path || "";
      document.getElementById("modalCategoryName").value = category.name;
      document.getElementById("modalCategoryIcon").value = category.icon || "";
      
      // Load existing metrics
      const metrics = metricDefinitions.filter(m => m.category_path === path);
      document.getElementById("metricsContainer").innerHTML = "";
      metricFieldCounter = 0;
      
      metrics.forEach(metric => {
        addMetricField(metric);
      });

      document.getElementById("categoryModal").classList.add("active");
    }

    function closeModal() {
      document.getElementById("categoryModal").classList.remove("active");
    }

    function addMetricField(existingMetric = null) {
      const container = document.getElementById("metricsContainer");
      const id = metricFieldCounter++;
      
      const div = document.createElement("div");
      div.className = "metric-input-group";
      div.id = `metricField_${id}`;
      
      const metricId = existingMetric ? existingMetric.id : null;
      
      div.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
          <strong>Metric ${id + 1}</strong>
          <button onclick="removeMetricField(${id})" class="danger" style="padding: 5px 10px;">Remove</button>
        </div>
        ${metricId ? `<input type="hidden" id="metricId_${id}" value="${metricId}">` : ''}
        <div class="form-group">
          <label>Metric Name</label>
          <input type="text" id="metricName_${id}" placeholder="e.g., Net Worth" value="${existingMetric?.metric_name || ''}">
        </div>
        <div class="form-group">
          <label>Unit</label>
          <input type="text" id="metricUnit_${id}" placeholder="e.g., USD, lbs, minutes" value="${existingMetric?.unit || ''}">
        </div>
        <div class="form-group">
          <label>Percentile Function (optional)</label>
          <select id="metricFunc_${id}">
            <option value="">None (manual entry)</option>
            ${getPercentileFunctionOptions(existingMetric?.percentile_function)}
          </select>
        </div>
      `;
      container.appendChild(div);
    }

    function getPercentileFunctionOptions(selectedFunc = null) {
      return percentileFunctionsConfig.functions.map(f => 
        `<option value="${f.value}" ${f.value === selectedFunc ? 'selected' : ''}>${f.label}</option>`
      ).join('');
    }

    function removeMetricField(id) {
      const field = document.getElementById(`metricField_${id}`);
      if (field) field.remove();
    }

    async function saveCategory() {
      const editPath = document.getElementById("modalEditPath").value;
      const isEdit = !!editPath;
      
      const parentPath = document.getElementById("modalParentSelect").value;
      const name = document.getElementById("modalCategoryName").value;
      const icon = document.getElementById("modalCategoryIcon").value;

      if (!name) {
        alert("Please enter a category name");
        return;
      }

      let path = editPath;
      
      if (!isEdit) {
        // Creating new category
        const safeName = name.toLowerCase().replace(/[^a-z0-9]/g, '_');
        path = parentPath ? `${parentPath}.${safeName}` : safeName;

        const { error: catError } = await supabase.from("category_structure").insert([{
          path,
          name,
          icon: icon || "",
          parent_path: parentPath || null
        }]);

        if (catError) {
          console.error(catError);
          alert("Failed to add category");
          return;
        }
      } else {
        // Editing existing category - FIXED VERSION
        const originalPath = document.getElementById("modalOriginalPath").value || editPath;
        const safeName = name.toLowerCase().replace(/[^a-z0-9]/g, '_');
        const newPath = parentPath ? `${parentPath}.${safeName}` : safeName;
        
        // If path changed (parent or name changed)
        if (newPath !== originalPath) {
          const descendants = getDescendants(originalPath);
          
          // Update the category itself
          const { error: updateError } = await supabase.from("category_structure").update({ 
            path: newPath, 
            name, 
            icon: icon || "", 
            parent_path: parentPath || null 
          }).eq("path", originalPath);
          
          if (updateError) {
            console.error(updateError);
            alert("Failed to update category");
            return;
          }
          
          // Update all descendants
          for (const desc of descendants) {
            const newDescPath = desc.path.replace(originalPath, newPath);
            const newDescParent = desc.parent_path ? desc.parent_path.replace(originalPath, newPath) : desc.parent_path;
            await supabase.from("category_structure").update({ 
              path: newDescPath, 
              parent_path: newDescParent 
            }).eq("path", desc.path);
            
            await supabase.from("metric_definitions").update({ category_path: newDescPath }).eq("category_path", desc.path);
            await supabase.from("metric_values").update({ category_path: newDescPath }).eq("category_path", desc.path);
          }
          
          // Update metrics and values for this category
          await supabase.from("metric_definitions").update({ category_path: newPath }).eq("category_path", originalPath);
          await supabase.from("metric_values").update({ category_path: newPath }).eq("category_path", originalPath);
          
          path = newPath;
        } else {
          // Just updating name/icon
          const { error: catError } = await supabase.from("category_structure").update({ name, icon: icon || "" }).eq("path", path);
          if (catError) {
            console.error(catError);
            alert("Failed to update category");
            return;
          }
        }
      
        // Delete removed metrics and update existing ones
        const existingMetrics = metricDefinitions.filter(m => m.category_path === path);
        const metricsToKeep = [];
        
        for (let i = 0; i < metricFieldCounter; i++) {
          const metricIdField = document.getElementById(`metricId_${i}`);
          if (metricIdField) {
            metricsToKeep.push(metricIdField.value);
          }
        }

        // Delete metrics not in the form
        for (const metric of existingMetrics) {
          if (!metricsToKeep.includes(metric.id)) {
            await supabase.from("metric_definitions").delete().eq("id", metric.id);
          }
        }
      }

      // Save/update metrics
      for (let i = 0; i < metricFieldCounter; i++) {
        const nameField = document.getElementById(`metricName_${i}`);
        if (!nameField) continue;
        
        const metricId = document.getElementById(`metricId_${i}`)?.value;
        const metricName = nameField.value;
        const unit = document.getElementById(`metricUnit_${i}`).value;
        const func = document.getElementById(`metricFunc_${i}`).value;

        if (metricName && unit) {
          const metricData = {
            category_path: path,
            metric_name: metricName,
            unit,
            percentile_function: func || null,
            parameters: func ? getParametersForFunction(func) : null
          };

          if (metricId) {
            // Update existing metric
            await supabase
              .from("metric_definitions")
              .update(metricData)
              .eq("id", metricId);
          } else {
            // Insert new metric
            await supabase.from("metric_definitions").insert([metricData]);
          }
        }
      }

      closeModal();
      await loadCategoryStructure();
      await loadMetricDefinitions();
      renderCategoryHierarchy();
      document.getElementById("status").textContent = isEdit ? "‚úÖ Category updated!" : "‚úÖ Category added!";
    }

    function getParametersForFunction(funcName) {
      return percentileFunctionsConfig.parameters[funcName] || ["value"];
    }

    // RENDER CATEGORY HIERARCHY
    function renderCategoryHierarchy() {
      const container = document.getElementById("categoryHierarchy");
      container.innerHTML = "";

      function renderTree(cats, parentElement) {
        cats.forEach(cat => {
          const item = document.createElement("div");
          item.className = "hierarchy-item";
          
          const metrics = metricDefinitions.filter(m => m.category_path === cat.path);
          const metricsText = metrics.length > 0 ? 
            ` (${metrics.length} metric${metrics.length > 1 ? 's' : ''})` : '';
          
          item.innerHTML = `
            <span>${cat.icon || ""}${cat.icon ? " " : ""}${cat.name}${metricsText}</span>
            <div>
              <button onclick="openEditCategoryModal('${cat.path}')" class="secondary" style="padding: 5px 10px; font-size: 14px;">Edit</button>
              <button onclick="deleteCategory('${cat.path}')" class="danger" style="padding: 5px 10px; font-size: 14px;">Delete</button>
            </div>
          `;
          parentElement.appendChild(item);

          if (cat.children && cat.children.length > 0) {
            const subtree = document.createElement("div");
            subtree.className = "hierarchy-tree";
            parentElement.appendChild(subtree);
            renderTree(cat.children, subtree);
          }
        });
      }

      const tree = buildCategoryTree();
      renderTree(tree, container);
    }

    // DELETE CATEGORY
    async function deleteCategory(path) {
      if (!confirm(`Delete "${path}" and all its sub-categories and metrics?`)) return;

      const descendants = getDescendants(path);
      const allPaths = [path, ...descendants.map(d => d.path)];

      await supabase.from("category_structure").delete().in("path", allPaths);
      await supabase.from("metric_definitions").delete().in("category_path", allPaths);

      await loadCategoryStructure();
      await loadMetricDefinitions();
      renderCategoryHierarchy();
      document.getElementById("status").textContent = "‚úÖ Category deleted!";
    }

    // LOAD WEIGHTS
    async function loadWeights() {
      const { data, error } = await supabase
        .from("category_weights")
        .select("*")
        .single();

      if (data) {
        currentWeights = data.weights || {};
      }

      const form = document.getElementById("weightsForm");
      form.innerHTML = "";
      
      getTopLevelCategories().forEach(cat => {
        const weight = currentWeights[cat.path] || 5;
        form.innerHTML += `
          <div class="form-group">
            <label>${cat.icon} ${cat.name}</label>
            <input type="range" id="weight_${cat.path}" min="1" max="10" value="${weight}" 
                   oninput="document.getElementById('weight_${cat.path}_val').textContent = this.value">
            <span id="weight_${cat.path}_val" style="margin-left: 10px; font-weight: bold;">${weight}</span>
          </div>
        `;
      });
    }

    // SAVE WEIGHTS
    async function saveWeights() {
      const weights = {};
      getTopLevelCategories().forEach(cat => {
        weights[cat.path] = parseInt(document.getElementById(`weight_${cat.path}`).value);
      });

      const { error } = await supabase
        .from("category_weights")
        .upsert({ id: 1, weights });

      if (error) {
        console.error(error);
        alert("Failed to save weights");
        return;
      }

      currentWeights = weights;
      document.getElementById("status").textContent = "‚úÖ Weights saved!";
      await loadDashboard();
    }

        // ==================== DATA HISTORY MANAGEMENT FUNCTIONS ====================
    
    function populateDataHistoryFilters() {
      const filterSelect = document.getElementById("filterCategory");
      if (!filterSelect) return;
      filterSelect.innerHTML = '<option value="">All Categories</option>';
      function addFilterOptions(cats, prefix = "") {
        cats.forEach(cat => {
          const option = document.createElement("option");
          option.value = cat.path;
          option.textContent = prefix + (cat.icon || "") + (cat.icon ? " " : "") + cat.name;
          filterSelect.appendChild(option);
          if (cat.children && cat.children.length > 0) addFilterOptions(cat.children, prefix + "  ");
        });
      }
      addFilterOptions(buildCategoryTree());
    }
    
    async function loadDataHistory() {
      const container = document.getElementById("dataHistoryTree");
      if (!container) return;
      container.innerHTML = "<p style='text-align: center; padding: 20px;'>Loading data...</p>";
      const filterCategory = document.getElementById("filterCategory").value;
      const filterStartDate = document.getElementById("filterStartDate").value;
      const filterEndDate = document.getElementById("filterEndDate").value;
      let query = supabase.from("metric_values").select("*").order("created_at", { ascending: false });
      if (filterCategory) {
        const descendants = getDescendants(filterCategory);
        const allPaths = [filterCategory, ...descendants.map(d => d.path)];
        query = query.in("category_path", allPaths);
      }
      if (filterStartDate) query = query.gte("created_at", new Date(filterStartDate).toISOString());
      if (filterEndDate) {
        const endDate = new Date(filterEndDate);
        endDate.setHours(23, 59, 59, 999);
        query = query.lte("created_at", endDate.toISOString());
      }
      const { data, error } = await query;
      if (error) {
        container.innerHTML = "<p class='no-data-message'>Error loading data</p>";
        return;
      }
      if (!data || data.length === 0) {
        container.innerHTML = "<p class='no-data-message'>No data entries found</p>";
        return;
      }
      const grouped = {};
      data.forEach(entry => {
        if (!grouped[entry.category_path]) grouped[entry.category_path] = [];
        grouped[entry.category_path].push(entry);
      });
      container.innerHTML = "";
      const tree = buildCategoryTree();
      renderDataTree(tree, container, grouped);
    }
    
    function renderDataTree(categories, parentElement, dataGrouped) {
      categories.forEach(cat => {
        const entries = dataGrouped[cat.path] || [];
        const hasData = entries.length > 0;
        const hasChildrenWithData = cat.children && cat.children.some(child => checkHasData(child, dataGrouped));
        if (!hasData && !hasChildrenWithData) return;
        const categoryDiv = document.createElement("div");
        categoryDiv.className = "tree-category";
        const header = document.createElement("div");
        header.className = "tree-category-header";
        if (expandedCategories.has(cat.path)) header.classList.add("expanded");
        header.innerHTML = `
          <div class="tree-category-title">
            <span class="tree-category-arrow ${expandedCategories.has(cat.path) ? 'expanded' : ''}">‚ñ∂</span>
            <span>${cat.icon} ${cat.name}</span>
            <span style="color: #999; font-size: 0.9em;">(${entries.length} entries)</span>
          </div>
        `;
        header.onclick = () => toggleCategoryExpansion(cat.path);
        categoryDiv.appendChild(header);
        const content = document.createElement("div");
        content.className = "tree-category-content";
        if (expandedCategories.has(cat.path)) content.classList.add("expanded");
        if (entries.length > 0) {
          entries.forEach(entry => {
            const entryDiv = createDataEntryElement(entry);
            content.appendChild(entryDiv);
          });
        }
        if (cat.children && cat.children.length > 0) {
          renderDataTree(cat.children, content, dataGrouped);
        }
        categoryDiv.appendChild(content);
        parentElement.appendChild(categoryDiv);
      });
    }
    
    function checkHasData(category, dataGrouped) {
      if (dataGrouped[category.path] && dataGrouped[category.path].length > 0) return true;
      if (category.children) {
        return category.children.some(child => checkHasData(child, dataGrouped));
      }
      return false;
    }
    
    function toggleCategoryExpansion(path) {
      if (expandedCategories.has(path)) {
        expandedCategories.delete(path);
      } else {
        expandedCategories.add(path);
      }
      loadDataHistory();
    }
    
    function createDataEntryElement(entry) {
      const div = document.createElement("div");
      div.className = "data-entry";
      div.id = `entry_${entry.id}`;
      if (editingEntries.has(entry.id)) div.classList.add("editing");
      const isEditing = editingEntries.has(entry.id);
      div.innerHTML = `
        <div class="data-entry-header">
          <div class="data-entry-date">${new Date(entry.created_at).toLocaleString()}</div>
          <div class="data-entry-actions">
            ${isEditing ? 
              `<button onclick="saveDataEntry('${entry.id}')" style="padding: 5px 15px;">Save</button>
               <button onclick="cancelEditDataEntry('${entry.id}')" class="secondary" style="padding: 5px 15px;">Cancel</button>` :
              `<button onclick="editDataEntry('${entry.id}')" class="secondary" style="padding: 5px 15px;">Edit</button>
               <button onclick="deleteDataEntry('${entry.id}')" class="danger" style="padding: 5px 15px;">Delete</button>`
            }
          </div>
        </div>
        <div class="data-entry-field">
          <label>Metric</label>
          <input type="text" value="${entry.metric_name}" disabled style="background: #1a1a2e; cursor: not-allowed;">
        </div>
        <div class="data-entry-field">
          <label>Value</label>
          <input type="number" step="any" id="value_${entry.id}" value="${entry.value}" ${isEditing ? '' : 'disabled'} style="${isEditing ? '' : 'background: #1a1a2e; cursor: not-allowed;'}">
        </div>
        <div class="data-entry-field">
          <label>Percentile</label>
          <input type="number" id="percentile_${entry.id}" value="${entry.percentile || ''}" ${isEditing ? '' : 'disabled'} style="${isEditing ? '' : 'background: #1a1a2e; cursor: not-allowed;'}">
        </div>
        <div class="data-entry-field">
          <label>Date/Time</label>
          <input type="datetime-local" id="datetime_${entry.id}" value="${new Date(entry.created_at).toISOString().slice(0, 16)}" ${isEditing ? '' : 'disabled'} style="${isEditing ? '' : 'background: #1a1a2e; cursor: not-allowed;'}">
        </div>
      `;
      return div;
    }
    
    function editDataEntry(entryId) {
      editingEntries.add(entryId);
      loadDataHistory();
    }
    
    function cancelEditDataEntry(entryId) {
      editingEntries.delete(entryId);
      loadDataHistory();
    }
    
    async function saveDataEntry(entryId) {
      const value = parseFloat(document.getElementById(`value_${entryId}`).value);
      const percentile = document.getElementById(`percentile_${entryId}`).value;
      const datetime = document.getElementById(`datetime_${entryId}`).value;
      const { error } = await supabase.from("metric_values").update({
        value,
        percentile: percentile ? parseFloat(percentile) : null,
        created_at: new Date(datetime).toISOString()
      }).eq("id", entryId);
      if (error) {
        alert("Failed to update entry");
        return;
      }
      editingEntries.delete(entryId);
      document.getElementById("status").textContent = "‚úÖ Entry updated!";
      await loadDataHistory();
      await loadDashboard();
      if (selectedCategory) await loadDetailStats(selectedCategory);
    }
    
    async function deleteDataEntry(entryId) {
      if (!confirm("Delete this entry permanently?")) return;
      const { error } = await supabase.from("metric_values").delete().eq("id", entryId);
      if (error) {
        alert("Failed to delete entry");
        return;
      }
      document.getElementById("status").textContent = "‚úÖ Entry deleted!";
      await loadDataHistory();
      await loadDashboard();
      if (selectedCategory) await loadDetailStats(selectedCategory);
    }
    
    function clearFilters() {
      document.getElementById("filterCategory").value = "";
      document.getElementById("filterStartDate").value = "";
      document.getElementById("filterEndDate").value = "";
      loadDataHistory();
    }
    
    // ==================== END DATA HISTORY FUNCTIONS ====================
    init();
  </script>
</body>
</html>
